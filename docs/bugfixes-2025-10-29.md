# Bug Fixes - October 29, 2025

## Summary
Fixed three critical bugs in the recording system that were blocking proper webcam preview and system audio recording functionality.

## Bug 1: Webcam Preview Blank Screen

**Issue**: Webcam preview displayed only a black screen despite the camera service working correctly.

**Root Cause**: Camera service outputs RGB pixel data (3 bytes per pixel), but JavaScript's ImageData API requires RGBA format (4 bytes per pixel with alpha channel).

**Fix**: Added RGB to RGBA conversion in `WebcamPreview.tsx` (lines 82-93)
```typescript
// Convert RGB to RGBA (ImageData requires RGBA format)
const pixelCount = width * height;
const rgbaBytes = new Uint8ClampedArray(pixelCount * 4);

for (let i = 0; i < pixelCount; i++) {
  const rgbIndex = i * 3;
  const rgbaIndex = i * 4;

  rgbaBytes[rgbaIndex] = rgbBytes[rgbIndex];         // R
  rgbaBytes[rgbaIndex + 1] = rgbBytes[rgbIndex + 1]; // G
  rgbaBytes[rgbaIndex + 2] = rgbBytes[rgbIndex + 2]; // B
  rgbaBytes[rgbaIndex + 3] = 255;                    // A (fully opaque)
}
```

**Impact**: Webcam preview now displays correctly in the UI.

---

## Bug 2: System Audio Not Recording for Screen Capture

**Issue**: Screen recordings had no system audio despite the infrastructure being in place.

**Root Cause**: System audio capture was not enabled in the recording command handler. ScreenCaptureKit audio support was implemented but not activated.

**Fix**: Modified `src-tauri/src/commands/recording.rs`:
1. Enabled system audio capture (line 759-764)
2. Created audio PCM writer task to save samples (lines 802-839)
3. Added FFmpeg audio muxing in cmd_stop_recording (lines 963-1021)
4. Updated RecordingHandle tuple structure to include audio writer handle

**Impact**: Screen recordings now include system audio (e.g., playing music, browser audio).

---

## Bug 3: Chipmunk Audio (High-Pitched System Audio) - FINAL FIX

**Issue**: System audio in screen recordings played back at incorrect pitch, sounding like chipmunks.

**Root Cause**: Sample rate mismatch - ScreenCaptureKit captures audio at the **system's native rate** (often 44.1kHz), NOT the requested rate (48kHz). The code was hardcoding 48kHz everywhere, causing a mismatch when the system was running at 44.1kHz. Playing 44.1kHz audio as 48kHz results in 1.088x speedup = chipmunk effect.

**Fix**: Modified both `src-tauri/src/services/screen_capture/screencapturekit.rs` AND `src-tauri/src/commands/recording.rs`:

### Part 1: Query System Audio Sample Rate (screencapturekit.rs lines 92-181)

Added function to query macOS system's default output device sample rate using Core Audio APIs:

```rust
fn get_system_output_sample_rate() -> Option<u32> {
    unsafe {
        // Query default output device ID
        let address = AudioObjectPropertyAddress {
            selector: kAudioHardwarePropertyDefaultOutputDevice,
            scope: kAudioObjectPropertyScopeGlobal,
            element: kAudioObjectPropertyElementMain,
        };

        AudioObjectGetPropertyData(
            kAudioObjectSystemObject,
            &address,
            ...
            &mut device_id
        );

        // Query device's nominal sample rate
        let rate_address = AudioObjectPropertyAddress {
            selector: kAudioDevicePropertyNominalSampleRate,
            ...
        };

        AudioObjectGetPropertyData(
            device_id,
            &rate_address,
            ...
            &mut sample_rate
        );

        Some(sample_rate as u32)
    }
}
```

### Part 2: Use Detected Rate in Audio Handler (screencapturekit.rs lines 241-250)

```rust
// Query system's actual output sample rate using Core Audio
// ScreenCaptureKit captures at the system's native rate, NOT the requested rate
let sample_rate = get_system_output_sample_rate().unwrap_or(48000);

debug!(
    "Extracted {} f32 samples from system audio buffer ({} channels), using system sample rate: {} Hz",
    samples.len(),
    num_channels,
    sample_rate
);
```

### Part 3: Capture and Store Sample Rate (recording.rs)

Modified `recording.rs` to capture and use the detected sample rate:

1. **Capture actual sample rate during recording** (lines 852-854, 872-881):
   - Create shared Arc<Mutex<Option<u32>>> to store detected sample rate
   - Extract sample rate from first AudioSample received (which now contains the system's rate from Core Audio)
   - Log detected sample rate for debugging

```rust
// Create shared storage for actual sample rate (will be set by first audio sample)
let actual_sample_rate = std::sync::Arc::new(std::sync::Mutex::new(None::<u32>));
let actual_sample_rate_clone = actual_sample_rate.clone();

// In audio writer loop:
if let Ok(mut rate) = actual_sample_rate_clone.lock() {
    if rate.is_none() {
        *rate = Some(audio_sample.sample_rate);
        info!("Detected system audio sample rate: {} Hz", audio_sample.sample_rate);
    }
}
```

2. **Store sample rate with recording** (line 922):
   - Updated RecordingHandle tuple to include actual_sample_rate
   - Pass actual_sample_rate when inserting recording into global state

3. **Use detected sample rate in FFmpeg muxing** (lines 1035-1041, 1050):
   - Extract actual_sample_rate from recording handle
   - Use detected rate in FFmpeg -ar parameter
   - Fallback to 48kHz if sample rate wasn't detected

```rust
// Get actual sample rate (fallback to 48000 if not detected)
let sample_rate = actual_sample_rate.lock()
    .ok()
    .and_then(|rate| *rate)
    .unwrap_or(48000);

info!("Using detected audio sample rate: {} Hz", sample_rate);

// FFmpeg command:
.arg("-ar").arg(sample_rate.to_string())  // Use actual detected rate
```

4. **Applied same fix to webcam recording** (lines 472-499):
   - Webcam microphone audio also tracks actual sample rate
   - Ensures consistent audio handling across all recording modes

**Impact**: System audio and microphone audio now play back at correct pitch and speed. The fix automatically adapts to whatever sample rate the system is using (44.1kHz, 48kHz, etc.).

---

## Bug 4: Missing Input Component (Build Error)

**Issue**: Vite dev server failed to compile with error: `Failed to resolve import "@/components/ui/input" from "src/components/recording/WindowSelector.tsx"`

**Root Cause**: The WindowSelector component (Story 4.1) was trying to import a `Input` component that didn't exist in the UI components directory.

**Fix**: Created `/src/components/ui/input.tsx`
- Implemented Input component following the same pattern as other UI components
- Uses shadcn/ui styling with Tailwind CSS
- Supports standard HTML input attributes
- Includes proper focus states, disabled states, and file input styling

```typescript
const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-gray-200 bg-white px-3 py-2 text-sm ring-offset-white file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-gray-950 placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-gray-950 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
```

**Impact**: Build errors resolved, dev server now runs without errors, WindowSelector search functionality works correctly.

---

## Bug 5: Microphone PCM Files Not Cleaned Up (Memory Leak)

**Issue**: Temporary microphone audio PCM files (`.mic.pcm`) were accumulating in the recordings directory, wasting disk space. A 5-second test recording could leave a 44MB orphaned PCM file.

**Root Cause**: In `cmd_stop_recording`, the microphone PCM path was extracted with underscore prefix (`_mic_audio_path`) indicating intentionally unused variable. While system audio PCM files were cleaned up after muxing (line 1252), microphone PCM files were never deleted.

**Fix**: Modified `src-tauri/src/commands/recording.rs`:

1. **Removed underscore prefix** (line 1161):
   ```rust
   // Before:
   _mic_audio_path,

   // After:
   mic_audio_path,
   ```

2. **Added cleanup logic** (lines 1305-1315):
   ```rust
   // Clean up microphone PCM file if it exists
   if let Some(mic_pcm_path) = mic_audio_path {
       if mic_pcm_path.exists() {
           info!("Cleaning up microphone PCM file: {}", mic_pcm_path.display());
           if let Err(e) = tokio::fs::remove_file(&mic_pcm_path).await {
               warn!("Failed to remove microphone PCM file: {}", e);
           } else {
               info!("Microphone PCM file removed successfully");
           }
       }
   }
   ```

**Impact**: Microphone PCM files are now automatically deleted after recording completes, preventing disk space waste. Only the final `.mp4` video file remains.

**Cleanup**: For existing orphaned files, run:
```bash
rm ~/Documents/clippy/recordings/*.pcm
rm ~/Documents/clippy/recordings/*.mic.pcm
```

---

## Testing Recommendations

1. **Webcam Preview**: Open Recording Panel → Select webcam → Verify video preview displays correctly
2. **System Audio Recording**:
   - Start screen recording
   - Play audio (music, video, etc.)
   - Stop recording and verify audio is present in exported file
   - Verify audio plays at correct pitch/speed (not chipmunk effect)
3. **Audio Quality**: Check that system audio quality is clear without distortion
4. **PCM File Cleanup** (Bug #5):
   - Record with microphone enabled
   - Stop recording
   - Verify only `.mp4` file exists in `~/Documents/clippy/recordings/`
   - Verify no `.mic.pcm` files remain after recording completes

---

## Related Stories

- Story 2.7: Basic Webcam Recording Setup (webcam preview fix)
- Story 2.4: System Audio and Microphone Capture (system audio fixes)
- Story 2.2: Full Screen Recording with Video Capture (system audio integration)

---

## Notes

- Webcam microphone audio still works independently for webcam recordings
- Screen recording now supports system audio but microphone audio is not yet integrated (future enhancement)
- Sample rate detection is robust with fallback to 48kHz if format description unavailable
