<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>5</epicId>
    <storyId>8</storyId>
    <title>Real-Time Performance Optimization</title>
    <status>drafted</status>
    <generatedAt>2025-10-29</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/5-8-real-time-performance-optimization.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user</asA>
    <iWant>smooth playback even with multi-track compositions</iWant>
    <soThat>I can edit without lag or stuttering</soThat>
    <tasks>
- Task 1: Implement FPS Monitoring Infrastructure (AC: #1)
  - Subtask 1.1: Create FPS counter in `PlaybackOrchestrator` (track frame timestamps)
  - Subtask 1.2: Add Tauri command `get_playback_fps()` returning current/average FPS
  - Subtask 1.3: Add FPS overlay to VideoPlayer component (dev mode only)
  - Subtask 1.4: Add toggle for FPS display in developer settings
  - Subtask 1.5: Write unit tests for FPS calculation logic

- Task 2: Implement Decode-Ahead Buffer (AC: #3)
  - Subtask 2.1: Design segment pre-loading queue (500ms lookahead)
  - Subtask 2.2: Implement background segment rendering for upcoming clips
  - Subtask 2.3: Add priority queue for segment cache (current > next > future)
  - Subtask 2.4: Add buffer monitoring (report buffer depth)
  - Subtask 2.5: Write integration tests for buffer behavior

- Task 3: Implement Frame Dropping Strategy (AC: #4)
  - Subtask 3.1: Add frame drop detection (timestamp gap > 33ms)
  - Subtask 3.2: Implement skip strategy (advance playhead without freeze)
  - Subtask 3.3: Add frame drop logging (tracing::warn!)
  - Subtask 3.4: Add recovery mechanism (reset to keyframe if excessive drops)
  - Subtask 3.5: Write stress tests for frame drop scenarios

- Task 4: Optimize Memory Usage (AC: #5)
  - Subtask 4.1: Profile current memory usage (baseline measurement)
  - Subtask 4.2: Implement segment cache eviction (LRU with 1GB max)
  - Subtask 4.3: Add memory monitoring metrics
  - Subtask 4.4: Optimize segment cache file sizes (tune FFmpeg CRF)
  - Subtask 4.5: Add memory usage assertions in tests (<1GB validation)

- Task 5: Optimize CPU Usage (AC: #6)
  - Subtask 5.1: Profile CPU hotspots (flamegraph analysis)
  - Subtask 5.2: Optimize segment rendering (FFmpeg ultrafast preset, limit threads)
  - Subtask 5.3: Offload rendering to background threads (Tokio spawn_blocking)
  - Subtask 5.4: Add CPU throttling for background tasks
  - Subtask 5.5: Validate CPU <80% with 3+ video + 4+ audio tracks

- Task 6: Optimize Scrubbing Performance (AC: #7)
  - Subtask 6.1: Measure baseline seek latency (current performance)
  - Subtask 6.2: Optimize segment cache lookup (in-memory index)
  - Subtask 6.3: Implement seek prediction (pre-cache likely seek targets)
  - Subtask 6.4: Add seek latency monitoring
  - Subtask 6.5: Write performance tests for scrub operations (<100ms target)

- Task 7: Multi-Track Performance Validation (AC: #2)
  - Subtask 7.1: Create complex test timeline (3 video + 4 audio tracks)
  - Subtask 7.2: Run playback with FPS monitoring enabled
  - Subtask 7.3: Validate sustained 60 FPS over 5-minute timeline
  - Subtask 7.4: Stress test with additional tracks (6 video + 8 audio)
  - Subtask 7.5: Document performance limits and degradation points

- Task 8: Performance Profiling Documentation (AC: #8)
  - Subtask 8.1: Document baseline performance metrics
  - Subtask 8.2: Document optimization strategies applied
  - Subtask 8.3: Document known performance bottlenecks
  - Subtask 8.4: Update architecture.md with profiling results
  - Subtask 8.5: Create performance tuning guide for future developers

- Task 9: Integration Testing
  - Subtask 9.1: Write integration test for FPS monitoring
  - Subtask 9.2: Write integration test for decode-ahead buffer
  - Subtask 9.3: Write integration test for frame dropping
  - Subtask 9.4: Write integration test for memory limits
  - Subtask 9.5: Write integration test for CPU usage
  - Subtask 9.6: Write integration test for scrub latency
  - Subtask 9.7: Add performance regression tests to CI/CD pipeline
</tasks>
  </story>

  <acceptanceCriteria>
1. Frame rate monitoring in dev mode shows FPS during playback
2. Maintain 60 FPS with 3+ video tracks + 4+ audio tracks
3. Decode-ahead buffer for upcoming clips (500ms ahead)
4. Frame dropping strategy for performance degradation (skip, not freeze)
5. Memory usage &lt; 1GB for typical 5-minute timeline
6. CPU usage &lt; 80% on MacBook Pro (2020+)
7. Smooth scrubbing through timeline (&lt; 100ms seek latency)
8. Performance profiling documented in architecture.md
</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>clippy Product Requirements Document</title>
        <section>NFR001: Performance</section>
        <snippet>Video playback shall maintain 60 FPS for 1080p composition rendering with smooth timeline playback. Composition renderer state updates shall complete in &lt;16ms to maintain 60 FPS responsiveness. Application shall launch in under 3 seconds.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>clippy Decision Architecture</title>
        <section>ADR-008: Timeline Composition Playback Architecture (Hybrid Smart Segment Pre-Rendering)</section>
        <snippet>Hybrid approach divides timeline into segments: Simple segments (single clip, single track) play directly via MPV; Complex segments (multi-track, gaps, overlapping) are pre-rendered via FFmpeg to cache. Performance targets: 60 FPS aspirational, &lt;100ms clip-to-clip transition, &lt;2s startup latency, &lt;1GB memory for 5-minute timeline, &lt;80% CPU on MacBook Pro 2020+.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>clippy Decision Architecture</title>
        <section>Performance Considerations</section>
        <snippet>NFR alignment includes 30+ FPS playback via optimized Konva.js timeline rendering. Architecture emphasizes hardware-accelerated decode (MPV), efficient FFmpeg pipeline management, and performance-first state management with Zustand.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 5: Timeline Composition Playback</title>
        <section>Story 5.8: Real-Time Performance Optimization</section>
        <snippet>Optimize composition renderer for 60 FPS sustained playback with multi-track timelines. Implement FPS monitoring, decode-ahead buffer, frame dropping strategy, and resource usage controls to meet professional editing standards.</snippet>
      </doc>
      <doc>
        <path>docs/stories/5-1-composition-playback-architecture-adr.md</path>
        <title>Story 5.1: Composition Playback Architecture &amp; ADR</title>
        <section>AC #4: Performance Benchmarks</section>
        <snippet>Documented performance benchmarks for Approach A (real-time MPV switching), Approach B (FFmpeg pre-render), and Approach C (hybrid smart segment pre-rendering). Benchmarks cover startup latency, memory usage, CPU utilization, and disk I/O requirements for each approach.</snippet>
      </doc>
      <doc>
        <path>docs/stories/5-2-composition-state-management.md</path>
        <title>Story 5.2: Composition State Management</title>
        <section>AC #8: Performance Target</section>
        <snippet>State updates must complete in &lt;16ms to maintain 60 FPS responsiveness. Measured via browser performance API to ensure composition state changes don't degrade playback performance.</snippet>
      </doc>
      <doc>
        <path>docs/stories/5-7-composition-export-parity-validation.md</path>
        <title>Story 5.7: Composition Export Parity Validation</title>
        <section>Testing Infrastructure</section>
        <snippet>Test framework infrastructure includes composition_parity_tests.rs, test fixtures (single-track, multi-track, gaps timelines), frame comparison logic, and audio waveform comparison utilities. Frame capture and timing validation infrastructure reusable for performance testing.</snippet>
      </doc>
      <doc>
        <path>docs/epic-3-retrospective.md</path>
        <title>Epic 3 Retrospective: Multi-Track Timeline &amp; Editing Maturity</title>
        <section>Action Items for Future Epics</section>
        <snippet>Epic 3 identified need for timeline interaction performance tests (60 FPS target per PRD NFR001). Recommendation: add performance benchmarking, improve CI/CD with compilation checks, create performance regression tests, and document when manual testing is acceptable for audio/visual verification.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/stores/compositionStore.ts</path>
        <kind>state-store</kind>
        <symbol>CompositionState, RenderState, ActiveClip</symbol>
        <lines>1-80</lines>
        <reason>Composition state management created in Story 5.2. Provides composition time tracking, active clips query, and render state. Performance target: state updates &lt;16ms (AC #8). Will need to integrate with performance monitoring for FPS tracking.</reason>
      </artifact>
      <artifact>
        <path>src-tauri/src/services/mpv_player.rs</path>
        <kind>service</kind>
        <symbol>MpvPlayer</symbol>
        <lines>1-100</lines>
        <reason>Existing MPV player service with hardware decoding (hwdec=auto), audio output enabled (audio=auto), and headless mode (vo=null). Base playback engine for composition renderer. Performance baseline: ~15-30% CPU for hardware decode playback.</reason>
      </artifact>
      <artifact>
        <path>src-tauri/src/services/ffmpeg/mod.rs</path>
        <kind>service-module</kind>
        <symbol>VideoExporter, FFmpegEncoder, FFmpegCompositor</symbol>
        <lines>1-7</lines>
        <reason>FFmpeg service layer providing exporter, encoder, and compositor. Used for complex segment rendering in hybrid architecture (ADR-008). Performance optimization will focus on encoder settings (ultrafast preset, thread limits) and compositor efficiency.</reason>
      </artifact>
      <artifact>
        <path>src/components/player/VideoPlayer.tsx</path>
        <kind>component</kind>
        <symbol>VideoPlayer</symbol>
        <lines>1-80</lines>
        <reason>Main video player component integrating MPV backend with composition state. Handles mode switching (preview vs timeline composition), playhead tracking, and gap detection. Will need FPS overlay UI (AC #1) and performance metrics display integration.</reason>
      </artifact>
      <artifact>
        <path>src-tauri/tests/test_4_7_integration.rs</path>
        <kind>test</kind>
        <symbol>test_4_7_integration</symbol>
        <lines>N/A</lines>
        <reason>Existing integration test pattern. Performance tests will follow similar structure for FPS validation, memory usage, and CPU profiling benchmarks.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="libmpv2" version="5.0">MPV bindings for video playback with hardware decode</package>
        <package name="ffmpeg-sidecar" version="2.1">FFmpeg CLI wrapper for encoding and compositing</package>
        <package name="tokio" version="1.x" features="full">Async runtime for background rendering tasks</package>
        <package name="tracing" version="0.1">Structured logging for performance metrics and frame drop warnings</package>
      </rust>
      <typescript>
        <package name="zustand" version="4.x">State management for composition store and performance metrics</package>
        <package name="react" version="18.x">Component library for FPS overlay UI</package>
      </typescript>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Follow Hybrid Smart Segment Pre-Rendering architecture (ADR-008): Simple segments play via MPV directly, complex segments pre-rendered via FFmpeg to cache (~/.Library/Caches/com.clippy.app/segments/)</constraint>
    <constraint>Maintain 60 FPS target with acceptable variance of Â±2 frames (33ms) matching Story 5.7 timing accuracy</constraint>
    <constraint>Memory budget: &lt;1GB total for 5-minute timeline (MPV base ~200MB, segment cache max 1GB with LRU eviction, decode-ahead buffer ~100MB)</constraint>
    <constraint>CPU budget: &lt;80% average on MacBook Pro 2020+ (MPV 15-30% during playback, FFmpeg 80-150% during transient background renders)</constraint>
    <constraint>Seek latency: &lt;100ms for cached segments, 3-5s acceptable for uncached first-play renders</constraint>
    <constraint>Use Tokio spawn_blocking for CPU-intensive FFmpeg rendering to avoid blocking async runtime</constraint>
    <constraint>Use tracing::warn! for frame drop logging, tracing::info! for performance metrics</constraint>
    <constraint>All performance metrics must use browser Performance API (frontend) or std::time::Instant (Rust backend) for accurate timing</constraint>
    <constraint>FPS overlay UI must only appear in dev mode (controlled by developer settings toggle)</constraint>
    <constraint>Frame dropping strategy: skip frames gracefully (advance playhead) instead of freezing; reset to keyframe if &gt;10 drops in 1 second</constraint>
    <constraint>Segment cache eviction: LRU policy with 1GB max, priority queue (current &gt; next &gt; future) for pre-loading</constraint>
    <constraint>FFmpeg optimization: ultrafast preset for segment rendering, limit thread count to prevent CPU saturation</constraint>
    <constraint>Testing: Extend Story 5.7's composition_parity_tests.rs infrastructure, reuse test fixtures (single-track, multi-track, gaps timelines)</constraint>
    <constraint>Performance profiling: Document baseline metrics, optimization strategies, known bottlenecks in architecture.md (AC #8)</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>FpsCounter (new)</name>
      <kind>Rust struct</kind>
      <signature>pub struct FpsCounter { frame_timestamps: VecDeque&lt;Instant&gt;, window_size: usize } impl FpsCounter { pub fn record_frame(&amp;mut self), pub fn get_fps(&amp;self) -&gt; f64 }</signature>
      <path>src-tauri/src/services/performance_monitor.rs (new file)</path>
    </interface>
    <interface>
      <name>SegmentPreloader (new)</name>
      <kind>Rust struct</kind>
      <signature>pub struct SegmentPreloader { render_queue: PriorityQueue&lt;SegmentId, Priority&gt;, background_renderer: Arc&lt;Mutex&lt;SegmentRenderer&gt;&gt; } impl SegmentPreloader { pub async fn enqueue_upcoming_segments(&amp;mut self, current_time: u64, timeline: &amp;Timeline) }</signature>
      <path>src-tauri/src/services/segment_preloader.rs (new file)</path>
    </interface>
    <interface>
      <name>get_playback_fps (new Tauri command)</name>
      <kind>Tauri command</kind>
      <signature>#[tauri::command] pub async fn get_playback_fps() -&gt; Result&lt;FpsMetrics, String&gt;</signature>
      <path>src-tauri/src/commands/performance.rs (new file)</path>
    </interface>
    <interface>
      <name>CompositionState.setCompositionTime (existing)</name>
      <kind>Zustand action</kind>
      <signature>setCompositionTime: (time: number) =&gt; void</signature>
      <path>src/stores/compositionStore.ts</path>
    </interface>
    <interface>
      <name>MpvPlayer.load_file (existing)</name>
      <kind>Rust method</kind>
      <signature>pub fn load_file(&amp;self, file_path: &amp;str) -&gt; Result&lt;()&gt;</signature>
      <path>src-tauri/src/services/mpv_player.rs</path>
    </interface>
  </interfaces>
  <tests>
    <standards>
      Testing follows Rust standard testing (cargo test) for backend performance benchmarks and Vitest + React Testing Library for frontend components. Performance tests extend Story 5.7's composition_parity_tests.rs infrastructure with FPS monitoring, memory profiling, and CPU usage validation. Manual testing required for visual performance verification (FPS overlay display, playback smoothness). All performance metrics must use std::time::Instant (Rust) or browser Performance API (TypeScript) for accurate timing measurements.
    </standards>
    <locations>
      - src-tauri/tests/performance_tests.rs (new file for performance benchmarks)
      - src-tauri/tests/composition_parity_tests.rs (existing, will be extended)
      - src-tauri/tests/fixtures/ (existing test timeline fixtures reused)
      - src/stores/compositionStore.test.ts (existing, may need performance assertions)
    </locations>
    <ideas>
      <test ac="1">Unit test: FpsCounter struct correctly calculates FPS from frame timestamps (60 frames over 1 second = 60 FPS)</test>
      <test ac="1">Integration test: get_playback_fps Tauri command returns current and average FPS during playback</test>
      <test ac="1">UI test: FPS overlay component displays and updates during playback in dev mode</test>
      <test ac="2">Performance benchmark: test_60fps_multi_track_playback validates sustained 60 FPS with 3 video + 4 audio tracks over 5 seconds</test>
      <test ac="2">Stress test: test_performance_degradation_graceful validates playback with 6 video + 8 audio tracks (exceeds target, should degrade gracefully)</test>
      <test ac="3">Integration test: test_decode_ahead_buffer validates segment pre-rendering within 500ms lookahead window</test>
      <test ac="3">Unit test: SegmentPreloader priority queue correctly orders segments (current > next > future)</test>
      <test ac="4">Unit test: Frame drop detection triggers when timestamp gap exceeds 33ms</test>
      <test ac="4">Integration test: test_frame_drop_recovery validates playhead advances during frame drops instead of freezing</test>
      <test ac="4">Stress test: test_excessive_frame_drops validates keyframe reset when >10 drops in 1 second</test>
      <test ac="5">Performance benchmark: test_memory_usage_under_1gb validates memory consumption for 5-minute timeline remains under 1GB</test>
      <test ac="5">Unit test: Segment cache LRU eviction triggers when cache size exceeds 1GB limit</test>
      <test ac="6">Performance benchmark: test_cpu_usage_under_80 validates CPU utilization during 3 video + 4 audio playback remains below 80%</test>
      <test ac="6">Integration test: Background rendering uses Tokio spawn_blocking and doesn't block main async runtime</test>
      <test ac="7">Performance benchmark: test_scrub_latency_under_100ms validates seek operations complete within 100ms for cached segments</test>
      <test ac="7">Integration test: Seek prediction pre-caches likely seek targets for improved scrub performance</test>
      <test ac="8">Manual verification: Performance profiling results documented in architecture.md with baseline metrics and optimization strategies</test>
    </ideas>
  </tests>
</story-context>
